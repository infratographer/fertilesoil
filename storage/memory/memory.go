// Package memory implements a memory storage backend for the
// fertilesoil storage interface.
// This is not meant to be the most useful nor the most performant
// storage backend, but rather a reference implementation which
// is useful for testing and development.
package memory

import (
	"context"
	"fmt"
	"sort"
	"sync"
	"time"

	"github.com/google/uuid"

	v1 "github.com/infratographer/fertilesoil/api/v1"
	"github.com/infratographer/fertilesoil/storage"
)

type Options func(*Driver)

type Driver struct {
	// dirMap is a thread-safe map of directories.
	dirMap *sync.Map
}

// WithDirectoryMap allows to set a custom directory map.
// This is useful for testing, since it allows to inject a custom
// map and further modify it in the test.
func WithDirectoryMap(dirMap *sync.Map) Options {
	return func(d *Driver) {
		d.dirMap = dirMap
	}
}

func NewDirectoryDriver(opts ...Options) *Driver {
	d := &Driver{
		dirMap: &sync.Map{},
	}

	for _, opt := range opts {
		opt(d)
	}

	return d
}

var _ storage.DirectoryAdmin = (*Driver)(nil)

// CreateRoot creates a root directory.
// Root directories are directories that have no parent directory.
// ID is generated by the database, it will be ignored if given.
func (t *Driver) CreateRoot(ctx context.Context, d *v1.Directory) (*v1.Directory, error) {
	if d.Parent != nil {
		return nil, storage.ErrRootWithParentDirectory
	}

	if d.Metadata == nil {
		d.Metadata = &v1.DirectoryMetadata{}
	}

	d.Id = v1.DirectoryID(uuid.New())
	d.CreatedAt = time.Now()
	d.UpdatedAt = time.Now()

	rawdir, _ := t.dirMap.LoadOrStore(d.Id, d)

	dir, ok := rawdir.(*v1.Directory)
	if !ok {
		return nil, fmt.Errorf("directory %s is not of type *v1.Directory", d.Id)
	}

	return dir, nil
}

// ListRoots lists all root directories.
func (t *Driver) ListRoots(ctx context.Context, options ...storage.Option) ([]v1.DirectoryID, error) {
	var roots []*v1.Directory

	opts := storage.BuildOptions(options)

	var iterationErr error

	t.dirMap.Range(func(key, value interface{}) bool {
		dir, ok := value.(*v1.Directory)
		if !ok {
			iterationErr = fmt.Errorf("found directory that is not of type *v1.Directory")
			return false
		}

		if (dir.DeletedAt == nil || opts.WithDeletedDirectories) && dir.Parent == nil {
			roots = append(roots, dir)
		}

		return true
	})

	if iterationErr != nil {
		return nil, iterationErr
	}

	if opts.GetPageOffset() > len(roots) {
		return nil, nil
	}

	// Sort the slice to ensure consistency.
	sort.Slice(roots, func(i, j int) bool {
		return roots[i].CreatedAt.Before(roots[j].CreatedAt)
	})

	limit := opts.GetPageOffset() + opts.GetPageSize()

	if limit > len(roots) {
		limit = len(roots)
	}

	rootIDs := make([]v1.DirectoryID, limit-opts.GetPageOffset())

	for i := range rootIDs {
		rootIDs[i] = roots[opts.GetPageOffset()+i].Id
	}

	return rootIDs, nil
}

// CreateDirectory creates a directory.
// ID is generated by the database, it will be ignored if given.
func (t *Driver) CreateDirectory(ctx context.Context, d *v1.Directory) (*v1.Directory, error) {
	if d.Parent == nil {
		return nil, storage.ErrDirectoryWithoutParent
	}

	if d.Metadata == nil {
		d.Metadata = &v1.DirectoryMetadata{}
	}

	d.Id = v1.DirectoryID(uuid.New())
	d.CreatedAt = time.Now()
	d.UpdatedAt = time.Now()

	rawdir, _ := t.dirMap.LoadOrStore(d.Id, d)

	dir, ok := rawdir.(*v1.Directory)
	if !ok {
		return nil, fmt.Errorf("directory %s is not of type *v1.Directory", d.Id)
	}

	return dir, nil
}

// UpdateDirectory updates the directory provided.
func (t *Driver) UpdateDirectory(ctx context.Context, d *v1.Directory) error {
	if d.Metadata == nil {
		d.Metadata = &v1.DirectoryMetadata{}
	}

	d.UpdatedAt = time.Now()

	t.dirMap.Store(d.Id, d)

	return nil
}

// DeleteDirectory deletes a directory.
func (t *Driver) DeleteDirectory(ctx context.Context, id v1.DirectoryID) ([]*v1.Directory, error) {
	dir, err := t.GetDirectory(ctx, id)
	if err != nil {
		return nil, err
	}

	if dir.Parent == nil {
		return nil, storage.ErrDirectoryNotFound
	}

	children, err := t.GetChildren(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("error getting children: %w", err)
	}

	deletedTime := time.Now()

	// length is the requested directory plus the count of children
	affected := make([]*v1.Directory, 1+len(children))

	dir.DeletedAt = &deletedTime

	affected[0] = dir

	for i, childID := range children {
		child, err := t.GetDirectory(ctx, childID)
		if err != nil {
			return nil, fmt.Errorf("error getting child: %s: %w", childID, err)
		}

		child.DeletedAt = &deletedTime

		affected[i+1] = child
	}

	return affected, nil
}

// GetDirectory gets a directory by ID.
func (t *Driver) GetDirectory(
	ctx context.Context,
	id v1.DirectoryID,
	options ...storage.Option,
) (*v1.Directory, error) {
	rawdir, ok := t.dirMap.Load(id)
	if !ok {
		return nil, storage.ErrDirectoryNotFound
	}

	dir, ok := rawdir.(*v1.Directory)
	if !ok {
		return nil, fmt.Errorf("directory %s is not of type *v1.Directory", id)
	}

	opts := storage.BuildOptions(options)

	if dir.DeletedAt != nil && !opts.WithDeletedDirectories {
		return nil, storage.ErrDirectoryNotFound
	}

	return dir, nil
}

// GetParents gets all parent directories of a directory.
func (t *Driver) GetParents(
	ctx context.Context,
	id v1.DirectoryID,
	options ...storage.Option,
) ([]v1.DirectoryID, error) {
	var (
		parentIDs []v1.DirectoryID
		parents   []*v1.Directory
	)

	opts := storage.BuildOptions(options)

	for {
		dir, err := t.GetDirectory(ctx, id, options...)
		if err != nil {
			return nil, err
		}

		// skips the first child
		if len(parentIDs) != 0 {
			parents = append(parents, dir)
		}

		if dir.Parent == nil {
			break
		}

		parentIDs = append(parentIDs, *dir.Parent)
		id = *dir.Parent
	}

	if opts.GetPageOffset() > len(parents) {
		return nil, nil
	}

	// Sort the slice to ensure consistency.
	sort.Slice(parentIDs, func(i, j int) bool {
		return parents[i].CreatedAt.Before(parents[j].CreatedAt)
	})

	limit := opts.GetPageOffset() + opts.GetPageSize()

	if limit > len(parentIDs) {
		limit = len(parentIDs)
	}

	return parentIDs[opts.GetPageOffset():limit], nil
}

// GetParentsUntilAncestor gets all parent directories of a directory
// until the ancestor directory is reached.
func (t *Driver) GetParentsUntilAncestor(
	ctx context.Context,
	child,
	ancestor v1.DirectoryID,
	options ...storage.Option,
) ([]v1.DirectoryID, error) {
	var (
		parentIDs []v1.DirectoryID
		parents   []*v1.Directory
	)

	opts := storage.BuildOptions(options)

	// verify that ancestor indeed exists
	ancestorDir, err := t.GetDirectory(ctx, ancestor, options...)
	if err != nil {
		return nil, err
	}

	for {
		dir, err := t.GetDirectory(ctx, child, options...)
		if err != nil {
			return nil, err
		}

		// skips the first child
		if len(parentIDs) != 0 {
			parents = append(parents, dir)
		}

		if dir.Parent == nil && dir.Id != ancestor {
			return nil, storage.ErrDirectoryNotFound
		}

		parentIDs = append(parentIDs, *dir.Parent)
		child = *dir.Parent

		if child == ancestor {
			parents = append(parents, ancestorDir)
			break
		}
	}

	if opts.GetPageOffset() > len(parents) {
		return nil, nil
	}

	// Sort the slice to ensure consistency.
	sort.Slice(parentIDs, func(i, j int) bool {
		return parents[i].CreatedAt.Before(parents[j].CreatedAt)
	})

	limit := opts.GetPageOffset() + opts.GetPageSize()

	if limit > len(parentIDs) {
		limit = len(parentIDs)
	}

	return parentIDs[opts.GetPageOffset():limit], nil
}

// getChildren retreives all child descendants for the provided parent.
func (t *Driver) getChildren(
	id v1.DirectoryID,
	opts *storage.Options,
) ([]*v1.Directory, error) {
	var iterationErr error

	childrenByParents := map[string][]*v1.Directory{}

	t.dirMap.Range(func(key, value interface{}) bool {
		dir, ok := value.(*v1.Directory)
		if !ok {
			iterationErr = fmt.Errorf("found directory that is not of type *v1.Directory")
			return false
		}

		// If item is deleted and WithDeletedDirectories is not enabled, skip.
		// We can also ignore root directory parents as there will never be a request from its parent.
		if dir.DeletedAt != nil && !opts.WithDeletedDirectories || dir.Parent == nil {
			return true
		}

		parent := dir.Parent.String()

		childrenByParents[parent] = append(childrenByParents[parent], dir)

		return true
	})

	if iterationErr != nil {
		return nil, iterationErr
	}

	children := append([]*v1.Directory{}, childrenByParents[id.String()]...)

	// Continuously look through all children and get their children.
	for i := 0; i < len(children); i++ {
		children = append(children, childrenByParents[children[i].Id.String()]...)
	}

	return children, nil
}

// GetChildren gets all child directories of a directory.
func (t *Driver) GetChildren(
	ctx context.Context,
	id v1.DirectoryID,
	options ...storage.Option,
) ([]v1.DirectoryID, error) {
	opts := storage.BuildOptions(options)

	children, err := t.getChildren(id, opts)
	if err != nil {
		return nil, err
	}

	if opts.GetPageOffset() > len(children) {
		return nil, nil
	}

	// Sort the slice to ensure consistency.
	sort.Slice(children, func(i, j int) bool {
		return children[i].CreatedAt.Before(children[j].CreatedAt)
	})

	limit := opts.GetPageOffset() + opts.GetPageSize()

	if limit > len(children) {
		limit = len(children)
	}

	childIDs := make([]v1.DirectoryID, limit-opts.GetPageOffset())

	for i := range childIDs {
		childIDs[i] = children[opts.GetPageOffset()+i].Id
	}

	return childIDs, nil
}
